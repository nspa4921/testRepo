// Code generated by SF Component Library Builder. DO NOT EDIT!
import { LightningElement, api } from "lwc";
import { THEME_BRAND_ATTRIBUTE, THEME_CONTEXT_ATTRIBUTE, THEME_COMPONENT_ATTRIBUTE } from "c/amThemeUtils";
export default class AmGlobalThemeProvider extends LightningElement {
  /** Global brand to use as base for unbranded components
   */
  _brand = "Default";

  @api
  get brand() {
    return this._brand;
  }

  set brand(val) {
    if (this._brand === val) {
      return;
    }

    this._brand = val;
    this.pushTheme = true;
  }
  /** Global Context for use as base for components missing context
   */


  _context = "Default";

  @api
  get context() {
    return this._context;
  }

  set context(val) {
    if (this._context === val) {
      return;
    }

    this._context = val;
    this.pushTheme = true;
  }
  /** Determine if root components should act like root components or nested components.
   * If true, the components will load Design Tokens
   */


  _root = true;

  @api
  get root() {
    return this._root;
  }

  set root(val) {
    this._root = val;
  }
  /** The component attribute can be used to create a component-context specific styling
   */


  _component = "Default";

  @api
  get component() {
    return this._component;
  }

  set component(val) {
    if (this._component === val) {
      return;
    }

    this._component = val;
    this.pushTheme = true;
  }
  /**
   * Traverse up through the document-fragment hierarchy and find the first Document node.
   * This should work both for LWC OS (Open Shadow Roots) and Salesforce (Synthetic-Shadow-Root)
   */


  getRootDocument(shadow) {
    var doc = shadow;

    while (doc.nodeType !== Node.DOCUMENT_NODE) {
      doc = doc.ownerDocument;
    }

    return doc;
  }
  /** Collection of subscribers to receive theme updates */


  subscribers = new Set();
  /**
   * Event handler setting the theme of the target element based on the current global theme,
   * and adding a subscription on theme changes for the element.
   */

  themeHandler = evt => {
    evt.detail.callbacks.setTheme(this.brand, this.context, this.root, this.component);
    this.subscribers.add(evt.detail.callbacks);
  };
  /**
   * Explicitly set the theme on all subscribers
   */

  refreshTheme() {
    this.subscribers.forEach(sub => sub.setTheme(this.brand, this.context, true, this.component));
  }
  /**
   * Document root
   */


  rootDoc;
  /**
   * Push new theme on next render
   */

  pushTheme = true;
  /** Invoked when the custom element is first connected to the document's DOM */

  connectedCallback() {
    this.rootDoc = this.getRootDocument(this.template);
    this.rootDoc.addEventListener("registration", this.themeHandler);
    this.rootDoc.body.setAttribute(THEME_BRAND_ATTRIBUTE, this.brand);
    this.rootDoc.body.setAttribute(THEME_CONTEXT_ATTRIBUTE, this.context);
    this.rootDoc.body.setAttribute(THEME_COMPONENT_ATTRIBUTE, this.component);
  }
  /** Invoked when the component rendering phase has completed */


  renderedCallback() {
    if (this.pushTheme) {
      this.pushTheme = false; //Update theme for previously themed components

      this.refreshTheme();
    }
  }
  /** Invoked when the custom element is disconnected from the document's DOM */


  disconnectedCallback() {
    this.rootDoc.removeEventListener("registration", this.themeHandler);
  }
  /**  Captures errors in all the child components in its tree during one of their lifecycle hooks */


  errorCallback(error, stack) {}

}